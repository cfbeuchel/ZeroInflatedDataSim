---
output:
  html_document:
    toc: true
    number_sections: false
    toc_depth: 3
author: "Carl Beuchel"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r knitr, cache = F, results = "markup", echo = T, warning = T}
# start with a clean workspace
rm(list=ls())
gc()

# Set the global knitr options
knitr::opts_chunk$set(cache = F, results = "hide", echo = T ,include = T)

# what should the output file be called?
filename = "Zero-inflated data simulation"
```

# `r filename`
***
This script is a small data simulation to help figure out an appropriate data transformation withouth loosing too much statistical power in the subsequent regression analyses.

```{r initiate, cache = F, results = "hide", echo = F}
# choose correct working directory
r_on_server <- T
if (r_on_server == T) {
  basicpath <- "/net/ifs1/san_projekte/projekte/"
} else {
  basicpath <- "/mnt/ifs1_projekte/"
}
setwd(basicpath)

# set working directory
pathwd <-
  paste0(
    basicpath,
    "genstat/02_projekte/1703_ge_metab_a1_b3_sorbs/171121_a1_b3_sorb_GxProbeAnnotTab"
  )
setwd(pathwd)

# get additional functions from Holger Kirstens newest RProfile file
newest_rprofile <-
  function(designation = paste0(basicpath, "genstat/07_programme/rtools/RProfile_hk/")) {
    files <- list.files(designation)
    RProfiles <- files[grep("Rprofile_hk_", files)]
    newest_RProfile <- tail(sort(RProfiles), n = 1)
    suppressPackageStartupMessages(source(paste0(designation, newest_RProfile)))
  }
newest_rprofile()

# start time measurement, define alternative package directory, define start codes for external start of the script
if (r_on_server == T) {
  initializeSkript(myfilename = filename, computer = "dunhargRRO") # enter which server you are on
} else
  initializeSkript(myfilename = filename, computer = "local")

# Packages for efficiently loading data
for (i in c(
  "knitr",
  "data.table",
  "broom",
  "ordinal",
  "MASS"
)) {
  suppressPackageStartupMessages(library(i, character.only = TRUE))
}
```

## Data simulation and setup

```{r setup}
# code by HKirsten (holgerman)
# set parameters for simulation, e.g. effect size, n...
set.seed(0815)

# magnitude of simulated effect  
effekte = c(0.01,0.02, 0.05, 0.1, 0.3)

# size of simulated data set
n = 5000

# magnitude of zero-inflation in %
proz0 = c(20, 50, 80)

# how often should each step be repeated?
realisierungen = 1000

# type of categories?
categart = c("quantile","bereiche")

# number of categories
categnum = c(2:10)
```

## Create scenarios

```{r create.scenarios}
# create dt with all scenario combinations
szenarien <- data.table(expand.grid(effekte = effekte,
                                    n = n,
                                    proz0 = proz0,
                                    categart = categart,
                                    categnum = categnum))
szenarien[,num := 1:.N]
```

## Create data and run lm

```{r test.data}
# apply over each szenario
apply(szenarien, 1, function(x) {
  
#   x <- szenarien[268, ] # debug
#   effekt <- x$effekte   # debug
#   n <- x$n # debug
#   proz0 <- x$proz0 # debug
#   categart <- x$categart # debug
#   categnum <- x$categnum # debug
#   num <- x$num # debug
  
  # for readability, assign parameters of each scenario
  effekt <- as.numeric(x[1])
  n <- as.numeric(x[2])
  proz0 <- as.numeric(x[3])
  categart <- x[4]
  categnum <- as.numeric(x[5])
  num <- as.numeric(x[6])
  
  # create data for scenario
  df <- data.table(x = rnorm(n))
  df[, y := x * effekt + rnorm(n) * (1 - effekt) + 2]
  
  # fit lm
  linmod <- df[, summary(lm(y ~ x))]
  
  # add summary statistics
  res <- data.table(num = num,
                    effekt = effekt,
                    n = n,
                    proz0 = proz0,
                    categart = categart,
                    categnum = categnum,
                    linmod.r2 = linmod$r.squared,
                    linmod.pval = linmod$coefficients["x","Pr(>|t|)"],
                    linmod.beta = linmod$coefficients["x","Estimate"])
  
  # create zero-inflated y-derived data
  df[, y.0infl := y]
  df[y < quantile(y.0infl, probs = proz0/100), y.0infl := 0]
  min.found = df[y.0infl > 0, min(y.0infl)]
  df[y.0infl > 0, y.0infl := y.0infl - 0.99*min.found]
  
  # check
  # df[,.N,y_0infl==0]
  # hist(df$y.0infl, breaks = 50)
  
  # sort by y (category)
  setorder(df, y)
  
  # create categories to calculate polr/ordinal over
  if(categart == "quantile") {
    
    # categorisation over quantiles
    df[y.0infl > 0, y.0infl.categ := cut(y.0infl, breaks = quantile(y.0infl, probs = seq(0, 1, 1/categnum)), include.lowest = T)]
    categs.created <- df[, levels(y.0infl.categ)]
    df[y.0infl == 0, y.0infl.categ := factor(0, labels =  "[0]")]
    df[, y.0infl.categ := factor(y.0infl.categ, levels = c("[0]", categs.created))]
  } else if(categart == "bereiche"){
    
    # category separating over range
    df[y.0infl > 0, y.0infl.categ := cut(y.0infl, breaks = seq(0, max(y.0infl), length.out = categnum + 1), include.lowest = T)]
    categs.created <- df[, levels(y.0infl.categ)]
    df[y.0infl == 0, y.0infl.categ := factor(0, labels =  "[0]")]
    df[, y.0infl.categ := factor(y.0infl.categ, levels = c("[0]", categs.created))]
    
  } else {
    stop("Error")
  }
  
  # now we have the complete data and start fitting the model
  # start with fitting the regular glm for a dichotomized y
  linmod.dicho <- df[, summary(glm(y.0infl > 0 ~ x))]
  
  # enter results
  res[, `:=`(dicho.pval = linmod.dicho$coefficients["x", "Pr(>|t|)"],
             dicho.beta = linmod.dicho$coefficients["x","Estimate"])]
  
  # fit the ordinal proportional odds model
  df[, MASS::polr(y.0infl.categ ~ x)]
  df[, ordinal::clm(y.0infl.categ ~ x)]

  
})
```

```{r template, include=F}
#===================================================================#
#Code template
#===================================================================#

myzeile  = x
df = data.table(x = rnorm(myzeile$n))
df[,y := x*myzeile$effekte + rnorm(myzeile$n)*(1- myzeile$effekte) +2]

linmod = df[,summary(lm(y~x))]
myzeile$linmod_r2 = linmod$r.squared
myzeile$linmod_pval = linmod$coefficients["x","Pr(>|t|)"]
myzeile$linmod_beta = linmod$coefficients["x","Estimate"]

df[,y_0infl := y]
df[ y<quantile(y_0infl, probs = myzeile$proz0/100), y_0infl := 0]
min_found = df[ y_0infl > 0, min(y_0infl)]
df[ y_0infl > 0, y_0infl := y_0infl - 0.99*min_found]

df[,.N,y_0infl==0]

# hist(df$y_0infl, breaks = 50)

setorder(df, y)
if(myzeile$categart == "quantile") {
  df[y_0infl > 0, y_0infl_categ := cut(y_0infl, breaks = quantile(y_0infl, probs = seq(0,1,1/myzeile$categnum)), include.lowest = T)]
  categs_created = df[,levels(y_0infl_categ)]
  df[y_0infl == 0, y_0infl_categ := factor(0, labels =  "[0]")]
  df[, y_0infl_categ := factor(y_0infl_categ, levels = c("[0]", categs_created))]
  }


## dichotomisiert 0 vs not 0 als glm


```